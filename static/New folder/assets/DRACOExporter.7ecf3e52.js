class d{parse(s,o={decodeSpeed:5,encodeSpeed:5,encoderMethod:d.MESH_EDGEBREAKER_ENCODING,quantization:[16,8,8,8,8],exportUvs:!0,exportNormals:!0,exportColor:!1}){if(s.isBufferGeometry===!0)throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");if(DracoEncoderModule===void 0)throw new Error("THREE.DRACOExporter: required the draco_encoder to work.");const u=s.geometry,r=DracoEncoderModule(),c=new r.Encoder;let i,n;if(u.isBufferGeometry!==!0)throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.");if(s.isMesh===!0){i=new r.MeshBuilder,n=new r.Mesh;const e=u.getAttribute("position");i.AddFloatAttributeToMesh(n,r.POSITION,e.count,e.itemSize,e.array);const a=u.getIndex();if(a!==null)i.AddFacesToMesh(n,a.count/3,a.array);else{const t=new(e.count>65535?Uint32Array:Uint16Array)(e.count);for(let l=0;l<t.length;l++)t[l]=l;i.AddFacesToMesh(n,e.count,t)}if(o.exportNormals===!0){const t=u.getAttribute("normal");t!==void 0&&i.AddFloatAttributeToMesh(n,r.NORMAL,t.count,t.itemSize,t.array)}if(o.exportUvs===!0){const t=u.getAttribute("uv");t!==void 0&&i.AddFloatAttributeToMesh(n,r.TEX_COORD,t.count,t.itemSize,t.array)}if(o.exportColor===!0){const t=u.getAttribute("color");t!==void 0&&i.AddFloatAttributeToMesh(n,r.COLOR,t.count,t.itemSize,t.array)}}else if(s.isPoints===!0){i=new r.PointCloudBuilder,n=new r.PointCloud;const e=u.getAttribute("position");if(i.AddFloatAttribute(n,r.POSITION,e.count,e.itemSize,e.array),o.exportColor===!0){const a=u.getAttribute("color");a!==void 0&&i.AddFloatAttribute(n,r.COLOR,a.count,a.itemSize,a.array)}}else throw new Error("DRACOExporter: Unsupported object type.");const E=new r.DracoInt8Array,O=o.encodeSpeed!==void 0?o.encodeSpeed:5,S=o.decodeSpeed!==void 0?o.decodeSpeed:5;if(c.SetSpeedOptions(O,S),o.encoderMethod!==void 0&&c.SetEncodingMethod(o.encoderMethod),o.quantization!==void 0)for(let e=0;e<5;e++)o.quantization[e]!==void 0&&c.SetAttributeQuantization(e,o.quantization[e]);let f;if(s.isMesh===!0?f=c.EncodeMeshToDracoBuffer(n,E):f=c.EncodePointCloudToDracoBuffer(n,!0,E),r.destroy(n),f===0)throw new Error("THREE.DRACOExporter: Draco encoding failed.");const A=new Int8Array(new ArrayBuffer(f));for(let e=0;e<f;e++)A[e]=E.GetValue(e);return r.destroy(E),r.destroy(c),r.destroy(i),A}}d.MESH_EDGEBREAKER_ENCODING=1;d.MESH_SEQUENTIAL_ENCODING=0;d.POINT_CLOUD=0;d.TRIANGULAR_MESH=1;d.INVALID=-1;d.POSITION=0;d.NORMAL=1;d.COLOR=2;d.TEX_COORD=3;d.GENERIC=4;export{d as DRACOExporter};
