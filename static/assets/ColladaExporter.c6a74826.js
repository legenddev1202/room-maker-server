import{m as x,n as W,h as V,D as J}from"./index.93204114.js";class te{parse(G,O,l={}){if(l=Object.assign({version:"1.4.1",author:null,textureDirectory:"",upAxis:"Y_UP",unitName:null,unitMeter:null},l),l.upAxis.match(/^[XYZ]_UP$/)===null)return console.error("ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP."),null;if(l.unitName!==null&&l.unitMeter===null)return console.error("ColladaExporter: unitMeter needs to be specified if unitName is specified."),null;if(l.unitMeter!==null&&l.unitName===null)return console.error("ColladaExporter: unitName needs to be specified if unitMeter is specified."),null;l.textureDirectory!==""&&(l.textureDirectory=`${l.textureDirectory}/`.replace(/\\/g,"/").replace(/\/+/g,"/"));const $=l.version;if($!=="1.4.1"&&$!=="1.5.0")return console.warn(`ColladaExporter : Version ${$} not supported for export. Only 1.4.1 and 1.5.0.`),null;function X(e){const r=/^<\//,t=/(\?>$)|(\/>$)/,a=/<[^>]+>[^<]*<\/[^<]+>/,n=(s,i)=>i>0?s+n(s,i-1):"";let c=0;return e.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map(s=>{!a.test(s)&&!t.test(s)&&r.test(s)&&c--;const i=`${n("  ",c)}${s}`;return!a.test(s)&&!t.test(s)&&!r.test(s)&&c++,i}).join(`
`)}function q(e){const r=atob(e),t=new Uint8Array(r.length);for(let a=0,n=t.length;a<n;a++)t[a]=r.charCodeAt(a);return t}let y,v;function U(e,r){y=y||document.createElement("canvas"),v=v||y.getContext("2d"),y.width=e.width,y.height=e.height,v.drawImage(e,0,0);const t=y.toDataURL(`image/${r}`,1).replace(/^data:image\/(png|jpg);base64,/,"");return q(t)}const P=["getX","getY","getZ","getW"],_=new x;function T(e,r=!1){if(r){const t=new Float32Array(e.count*3);for(let a=0,n=e.count;a<n;a++)_.fromBufferAttribute(e,a).convertLinearToSRGB(),t[3*a+0]=_.r,t[3*a+1]=_.g,t[3*a+2]=_.b;return t}else if(e.isInterleavedBufferAttribute){const t=new e.array.constructor(e.count*e.itemSize),a=e.itemSize;for(let n=0,c=e.count;n<c;n++)for(let s=0;s<a;s++)t[n*a+s]=e[P[s]](n);return t}else return e.array}function Y(e,r,t){return Array.isArray(e)?e.slice(r,r+t):new e.constructor(e.buffer,r*e.BYTES_PER_ELEMENT,t)}function g(e,r,t,a,n=!1){const c=T(e,n);return`<source id="${r}"><float_array id="${r}-array" count="${c.length}">`+c.join(" ")+`</float_array><technique_common><accessor source="#${r}-array" count="${Math.floor(c.length/e.itemSize)}" stride="${e.itemSize}">`+t.map(i=>`<param name="${i}" type="${a}" />`).join("")+"</accessor></technique_common></source>"}let h;function k(e){return e.updateMatrix(),h=h||new V,h.copy(e.matrix),h.transpose(),`<matrix>${h.toArray().join(" ")}</matrix>`}function z(e){let r=C.get(e);if(!r){const t=e;if(t.isBufferGeometry!==!0)throw new Error("THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.");const a=`Mesh${M.length+1}`,n=t.index?t.index.count*t.index.itemSize:t.attributes.position.count,c=t.groups!=null&&t.groups.length!==0?t.groups:[{start:0,count:n,materialIndex:0}],s=e.name?` name="${e.name}"`:"";let i=`<geometry id="${a}"${s}><mesh>`;const u=`${a}-position`,p=`${a}-vertices`;i+=g(t.attributes.position,u,["X","Y","Z"],"float"),i+=`<vertices id="${p}"><input semantic="POSITION" source="#${u}" /></vertices>`;let f=`<input semantic="VERTEX" source="#${p}" offset="0" />`;if("normal"in t.attributes){const o=`${a}-normal`;i+=g(t.attributes.normal,o,["X","Y","Z"],"float"),f+=`<input semantic="NORMAL" source="#${o}" offset="0" />`}if("uv"in t.attributes){const o=`${a}-texcoord`;i+=g(t.attributes.uv,o,["S","T"],"float"),f+=`<input semantic="TEXCOORD" source="#${o}" offset="0" set="0" />`}if("uv2"in t.attributes){const o=`${a}-texcoord2`;i+=g(t.attributes.uv2,o,["S","T"],"float"),f+=`<input semantic="TEXCOORD" source="#${o}" offset="0" set="1" />`}if("color"in t.attributes){const o=`${a}-color`;i+=g(t.attributes.color,o,["R","G","B"],"float",!0),f+=`<input semantic="COLOR" source="#${o}" offset="0" />`}let d=null;if(t.index)d=T(t.index);else{d=new Array(n);for(let o=0,A=d.length;o<A;o++)d[o]=o}for(let o=0,A=c.length;o<A;o++){const D=c[o],B=Y(d,D.start,D.count),Z=B.length/3;i+=`<triangles material="MESH_MATERIAL_${D.materialIndex}" count="${Z}">`,i+=f,i+=`<p>${B.join(" ")}</p>`,i+="</triangles>"}i+="</mesh></geometry>",M.push(i),r={meshid:a,bufferGeometry:t},C.set(e,r)}return r}function b(e){let r=R.get(e);if(r==null){r=`image-${w.length+1}`;const t="png",a=e.name||r;let n=`<image id="${r}" name="${a}">`;$==="1.5.0"?n+=`<init_from><ref>${l.textureDirectory}${a}.${t}</ref></init_from>`:n+=`<init_from>${l.textureDirectory}${a}.${t}</init_from>`,n+="</image>",w.push(n),R.set(e,r),L.push({directory:l.textureDirectory,name:a,ext:t,data:U(e.image,t),original:e})}return r}function H(e){let r=N.get(e);if(r==null){r=`Mat${E.length+1}`;let t="phong";e.isMeshLambertMaterial===!0?t="lambert":e.isMeshBasicMaterial===!0&&(t="constant",e.map!==null&&console.warn("ColladaExporter: Texture maps not supported with MeshBasicMaterial."));const a=e.emissive?e.emissive:new x(0,0,0),n=e.color?e.color:new x(0,0,0),c=e.specular?e.specular:new x(1,1,1),s=e.shininess||0,i=e.reflectivity||0;a.convertLinearToSRGB(),c.convertLinearToSRGB(),n.convertLinearToSRGB();let u="";e.transparent===!0&&(u+="<transparent>"+(e.map?'<texture texture="diffuse-sampler"></texture>':"<float>1</float>")+"</transparent>",e.opacity<1&&(u+=`<transparency><float>${e.opacity}</float></transparency>`));const p=`<technique sid="common"><${t}><emission>`+(e.emissiveMap?'<texture texture="emissive-sampler" texcoord="TEXCOORD" />':`<color sid="emission">${a.r} ${a.g} ${a.b} 1</color>`)+"</emission>"+(t!=="constant"?"<diffuse>"+(e.map?'<texture texture="diffuse-sampler" texcoord="TEXCOORD" />':`<color sid="diffuse">${n.r} ${n.g} ${n.b} 1</color>`)+"</diffuse>":"")+(t!=="constant"?"<bump>"+(e.normalMap?'<texture texture="bump-sampler" texcoord="TEXCOORD" />':"")+"</bump>":"")+(t==="phong"?`<specular><color sid="specular">${c.r} ${c.g} ${c.b} 1</color></specular><shininess>`+(e.specularMap?'<texture texture="specular-sampler" texcoord="TEXCOORD" />':`<float sid="shininess">${s}</float>`)+"</shininess>":"")+`<reflective><color>${n.r} ${n.g} ${n.b} 1</color></reflective><reflectivity><float>${i}</float></reflectivity>`+u+`</${t}></technique>`,f=`<effect id="${r}-effect"><profile_COMMON>`+(e.map?`<newparam sid="diffuse-surface"><surface type="2D"><init_from>${b(e.map)}</init_from></surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`:"")+(e.specularMap?`<newparam sid="specular-surface"><surface type="2D"><init_from>${b(e.specularMap)}</init_from></surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>`:"")+(e.emissiveMap?`<newparam sid="emissive-surface"><surface type="2D"><init_from>${b(e.emissiveMap)}</init_from></surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`:"")+(e.normalMap?`<newparam sid="bump-surface"><surface type="2D"><init_from>${b(e.normalMap)}</init_from></surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>`:"")+p+(e.side===J?'<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>':"")+"</profile_COMMON></effect>",d=e.name?` name="${e.name}"`:"",o=`<material id="${r}"${d}><instance_effect url="#${r}-effect" /></material>`;I.push(o),E.push(f),N.set(e,r)}return r}function S(e){let r=`<node name="${e.name}">`;if(r+=k(e),e.isMesh===!0&&e.geometry!==null){const t=z(e.geometry),a=t.meshid,n=t.bufferGeometry;let c=null,s;const i=e.material||new W,u=Array.isArray(i)?i:[i];n.groups.length>u.length?s=new Array(n.groups.length):s=new Array(u.length),c=s.fill().map((p,f)=>H(u[f%u.length])),r+=`<instance_geometry url="#${a}">`+(c.length>0?"<bind_material><technique_common>"+c.map((p,f)=>`<instance_material symbol="MESH_MATERIAL_${f}" target="#${p}" ><bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`).join("")+"</technique_common></bind_material>":"")+"</instance_geometry>"}return e.children.forEach(t=>r+=S(t)),r+="</node>",r}const C=new WeakMap,N=new WeakMap,R=new WeakMap,L=[],w=[],M=[],E=[],I=[],F=S(G);let m=`<?xml version="1.0" encoding="UTF-8" standalone="no" ?><COLLADA xmlns="${$==="1.4.1"?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/"}" version="${$}"><asset>`+("<contributor><authoring_tool>three.js Collada Exporter</authoring_tool>"+(l.author!==null?`<author>${l.author}</author>`:"")+`</contributor><created>${new Date().toISOString()}</created><modified>${new Date().toISOString()}</modified>`+(l.unitName!==null?`<unit name="${l.unitName}" meter="${l.unitMeter}" />`:"")+`<up_axis>${l.upAxis}</up_axis>`)+"</asset>";m+=`<library_images>${w.join("")}</library_images>`,m+=`<library_effects>${E.join("")}</library_effects>`,m+=`<library_materials>${I.join("")}</library_materials>`,m+=`<library_geometries>${M.join("")}</library_geometries>`,m+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${F}</visual_scene></library_visual_scenes>`,m+='<scene><instance_visual_scene url="#Scene"/></scene>',m+="</COLLADA>";const j={data:X(m),textures:L};return typeof O=="function"&&requestAnimationFrame(()=>O(j)),j}}export{te as ColladaExporter};
